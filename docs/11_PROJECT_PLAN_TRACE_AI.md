아주 좋은 질문입니다.

지금 단계에서 **“작업내용을 상세하게 적은 버전”**을 만드는 것은 과도하지 않고, 오히려 이 문서를 **진짜 실행 문서**로 격상시키는 작업입니다.

아래에 **작업내용을 상세화한 최종 버전의 `11_PROJECT_PLAN_TRACE_AI.md` 전체 내용**을 제공합니다.

> 설계 의도
>
> - ✔ WBS는 그대로 유지
> - ✔ 각 작업에 **“무엇을 구현하는지 / 어디까지가 범위인지”를 명확히 기술**
> - ✔ 읽으면 _오늘 무엇을 손대야 하는지 바로 알 수 있는 수준_
> - ✔ 그래도 “고도화 유혹”은 차단됨

---

# 11. TRACE-AI Project Plan (4 Weeks)

- 프로젝트명: TRACE-AI
- 기간: 4주 (28일)
- 목표: **해커톤 시연 가능한 엔터프라이즈 AI Agent MVP 완성**
- 핵심 원칙: **범위 고정 / 고도화 금지 / 흐름 우선 / run_id 기반 추적**

---

## 1. 운영 원칙 (변경 금지)

### 1.1 Definition of Done (완료 기준)

다음 조건을 모두 만족하면 **완료**로 간주한다.

- 기능이 “존재”한다 (mock 포함)
- LangGraph 기준 END 상태까지 도달한다
- run_id 기준으로 판단·승인·실행·로그·감사를 설명할 수 있다

---

### 1.2 범위 통제 규칙

- ❌ 새로운 기능 추가 금지
- ❌ 성능 최적화 / 고급 패턴 / Agent 실험 금지
- ⭕ 주차 목표 미달 시 **이월 금지**, 대신 **범위 축소**
- ⭕ “잘 만든 일부”보다 “끝까지 이어지는 전체”

---

## 2. Git Workflow (전역 규칙)

### 2.1 브랜치 네이밍 규칙

```
w{주차}-{작업번호}-{요약}

```

예:

- `w1-2-run-id-plumbing`
- `w2-3-rca-subgraph`

---

### 2.2 커밋 메시지 규칙

```
[W{주차}-{작업번호}] <행동 + 결과>

```

예:

- `[W1-2] generate and propagate run_id`
- `[W3-3] generate audit summary per run`

---

### 2.3 작업–Git 매핑 원칙

- WBS 작업 1개 = 브랜치 1개
- 체크리스트 100% 충족 후 main 병합
- 체크리스트 미완료 상태에서 merge 금지

---

## 3. 4주 WBS + 상세 작업내용 + 실행 체크리스트

---

# WEEK 1 — 뼈대 고정 (Architecture First)

> 주 목표
>
> “기능 품질과 무관하게, 시스템이 끝까지 흐를 수 있는 구조 확보”

---

### W1-1 프로젝트 초기 구조 구성

**작업 목적**

TRACE-AI의 전체 개발을 수용할 수 있는 최소한의 서버·디렉터리·설정 구조를 만든다.

이 단계에서는 기능 구현이 아니라 **‘자리 잡기’**가 목적이다.

**작업 내용**

- FastAPI 프로젝트 생성
- `app/`, `api/`, `agent/`, `core/`, `logs/` 디렉터리 생성
- 환경변수 로딩 구조 (`.env`, `.env.example`)
- `/api/v1/health` 엔드포인트 추가
- README에 실행 방법 최소 문구 추가

**브랜치**

- `w1-1-project-skeleton`

**체크리스트**

- [x] FastAPI 서버 기동
- [x] `/api/v1/health` 200 OK
- [x] 디렉터리 구조 확정
- [x] README 실행 방법 작성

---

### W1-2 run_id 기반 실행 골격

**작업 목적**

TRACE-AI의 모든 판단·실행·로그·감사를 하나의 실행 단위(run)로 묶기 위한 **핵심 기반**을 만든다.

**작업 내용**

- 요청 진입 시 UUID 기반 run_id 생성
- FastAPI request context에 run_id 저장
- LangGraph State에 run_id 포함
- 응답 JSON에 run_id 포함
- 기본 로그 출력 시 run_id 포함

**브랜치**

- `w1-2-run-id-plumbing`

**체크리스트**

- [x] 요청마다 run_id 생성
- [x] LangGraph State에 run_id 존재
- [x] API 응답에 run_id 포함
- [x] 로그에서 run_id 확인 가능
- [x] 단일 run 추적 가능

---

### W1-3 LangGraph Orchestrator 기본 흐름

**작업 목적**

TRACE-AI의 모든 기능이 얹힐 **LangGraph 실행 뼈대**를 만든다.

**작업 내용**

- Orchestrator Graph 생성
- Dummy Node 생성
- START → Dummy Node → END 구성
- Node 실행 전/후 로그 출력
- State 전달 구조 확인

**브랜치**

- `w1-3-langgraph-orchestrator`

**체크리스트**

- [x] Graph 실행 성공
- [x] 최소 3개 Node 존재
- [x] Node start/end 로그 출력

---

### W1-4 UI ↔ API 연결

**작업 목적**

사용자 입력이 실제 서버 실행으로 이어지고 결과가 다시 UI로 돌아오는 **최소 왕복 흐름 확보**.

**작업 내용**

- Chainlit 기본 UI 구성
- 사용자 입력 → FastAPI 호출
- API 응답 → UI 출력
- run_id 화면 표시

**브랜치**

- `w1-4-ui-api-bridge`

**체크리스트**

- [ ] UI에서 입력 가능
- [ ] API 호출 성공
- [ ] 응답 UI 출력
- [ ] run_id 표시

---

### W1-5 Week 1 종료 점검

**작업 목적**

Week 1의 모든 구성 요소가 하나의 흐름으로 연결되는지 최종 확인.

**작업 내용**

- 전체 실행 1회
- 오류 발생 시에도 END 도달 확인
- 로그 파일 생성 여부 확인

**브랜치**

- `w1-5-week1-smoke`

**체크리스트**

- [x] END 상태 도달
- [x] 오류 발생해도 흐름 유지
- [x] 로그 존재

---

# Week 1 공식 완료 선언

> Week 1 완료(W1-1~W1-5).
> 
> FastAPI 서버 기동, run_id 생성/전파, LangGraph 오케스트레이터(START→DUMMY→END) 실행, Chainlit UI 연동을 완료했으며, UI→API→LangGraph 왕복 스모크 테스트 2회(서로 다른 run_id) 성공으로 전체 실행 흐름과 추적 가능성을 검증함.

---

# WEEK 2 — 핵심 기능 연결 (TOP3)

> 주 목표
>
> 규정 감지 + 장애 RCA + 업무 실행 계획이 하나의 run 안에서 동작

---

### W2-1 지식 저장소 업로드 파이프라인

**작업 목적**

AI 판단의 근거가 되는 문서를 시스템이 “기억”할 수 있게 만든다.

**작업 내용**

- 문서 업로드 API 구현
- 텍스트 파싱
- 청크 분할
- 임베딩 생성
- Vector DB 저장
- 단순 검색 API 구현

**브랜치**

- `w2-1-knowledge-ingest`

**체크리스트**

- [ ] 문서 업로드 가능
- [ ] 임베딩 생성 성공
- [ ] 검색 결과 반환

---

### W2-2 규정 위반 감지 서브그래프

**작업 목적**

입력 내용이 내부 규정을 위반하는지 **근거 기반으로 판단**.

**작업 내용**

- 입력 분석
- 정책 지식 저장소 검색
- 위반/비위반/잠재적 위반 판단
- Evidence 구성

**브랜치**

- `w2-2-compliance-subgraph`

**체크리스트**

- [ ] 정책 검색
- [ ] 위반 판단
- [ ] Evidence 출력

---

### W2-3 장애 RCA 서브그래프

**작업 목적**

로그/장애 설명을 기반으로 **원인 가설 + 근거**를 제시.

**작업 내용**

- 로그 입력 처리
- 장애 지식 저장소 검색
- 복수 가설 생성
- 우선순위 정렬

**브랜치**

- `w2-3-rca-subgraph`

**체크리스트**

- [ ] 로그 입력 처리
- [ ] 유사 사례 검색
- [ ] Top-N 가설 반환

---

### W2-4 업무 실행 계획 서브그래프

**작업 목적**

판단 결과를 실제 “조치 계획” 형태로 변환.

**작업 내용**

- Action Plan 생성
- 단계별 설명
- 위험도 분류
- 승인 필요 여부 설정

**브랜치**

- `w2-4-workflow-subgraph`

**체크리스트**

- [ ] Action Plan 생성
- [ ] 위험도 부여
- [ ] 승인 필요 단계 표시

---

### W2-5 서브그래프 통합

**작업 목적**

여러 판단 결과를 하나의 실행 컨텍스트로 통합.

**작업 내용**

- intent 분기
- 다중 서브그래프 실행
- 결과 병합

**브랜치**

- `w2-5-merge-subgraphs`

**체크리스트**

- [ ] intent 분기 동작
- [ ] mixed 요청 처리
- [ ] 결과 병합 성공

---

# WEEK 3 — 로그·감사 & 안정화

> 주 목표
>
> “왜 이런 판단과 실행이 나왔는지 설명 가능”

---

### W3-1 구조화 로그 시스템

**작업 내용**

- JSON 로그 포맷
- Node start/end
- 판단/실행 로그

---

### W3-2 승인(Human-in-the-loop)

**작업 내용**

- 승인 대기 상태
- 승인 API
- 승인 후 재개

---

### W3-3 감사(Audit) 요약 생성

**작업 내용**

- run 단위 감사 JSON
- 판단·근거·승인·실행 포함

---

### W3-4 오류 처리 안정화

**작업 내용**

- LLM 실패 처리
- 검색 실패 처리
- 실패해도 감사 생성

---

### W3-5 데모 리허설 1차

**작업 내용**

- 전체 시나리오 1회 실행
- 설명 흐름 점검

---

# WEEK 4 — 데모 완성 & 정리

> 주 목표
>
> “보여줄 수 있는 상태로 고정하고 멈춘다”

---

### W4-1 데모 시나리오 고정

### W4-2 UI 가독성 개선

### W4-3 문서 최종 점검

### W4-4 최종 리허설

### W4-5 종료 선언 (Code Freeze)

---

## 4. 최종 한 문장 요약

> 이 문서는무엇을 더 만들지 결정하는 문서가 아니라무엇을 안 만들어도 되는지를 결정하는 문서다.

---

### 다음 제안

이제 다음 중 하나를 하면 흐름이 가장 좋습니다.

1. **Week 2 Day 단위 상세 계획 작성**
2. **Week 1 회고 섹션 추가**
3. **이 문서를 기준으로 한 실제 디렉터리 구조 스켈레톤 제시**

원하시는 방향을 말씀해 주세요.
